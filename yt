#! /usr/bin/env ruby
# frozen_string_literal: true

# Eric's Offline YouTube (Download YT videos via Downie with JSON metadata and image previews and then run this script)

require 'English'
require 'fileutils'
require 'bundler/inline'
require 'digest'

gemfile do
  source 'https://rubygems.org'

  gem 'json'
  gem 'pry'
  gem 'puma'
  gem 'sinatra'
  gem 'rackup'
  gem 'net-http'
end

DOWNLOAD_PATH = "#{Dir.home}/Downloads/YouTube/"
CHANNEL_CACHE_FILE = "#{DOWNLOAD_PATH}channel_cache.json"
SLUG_CACHE_FILE = "#{DOWNLOAD_PATH}slug_cache.json"
END_OF_FILE = defined?(DATA) ? DATA.pos.freeze : 0

# Manages caching of YouTube channel URLs to avoid repeated API lookups
class ChannelCache
  def self.load_cache
    return {} unless File.exist?(CHANNEL_CACHE_FILE)

    JSON.parse(File.read(CHANNEL_CACHE_FILE, encoding: 'UTF-8'))
  rescue StandardError
    {}
  end

  def self.save_cache(cache)
    File.write(CHANNEL_CACHE_FILE, cache.to_json, encoding: 'UTF-8')
  rescue StandardError
    # Silently fail if we can't write
  end

  def self.get_url(channel_name)
    cache = load_cache
    cache[channel_name]
  end

  def self.set_url(channel_name, url)
    cache = load_cache
    cache[channel_name] = url
    save_cache(cache)
  end
end

# Manages mapping between URL-friendly slugs and video file paths
class SlugCache
  def self.load_cache
    return {} unless File.exist?(SLUG_CACHE_FILE)

    JSON.parse(File.read(SLUG_CACHE_FILE, encoding: 'UTF-8'))
  rescue StandardError
    {}
  end

  def self.save_cache(cache)
    File.write(SLUG_CACHE_FILE, cache.to_json, encoding: 'UTF-8')
  rescue StandardError
    # Silently fail if we can't write
  end

  def self.get_file_path(slug)
    cache = load_cache
    cache[slug]
  end

  def self.set_mapping(slug, file_path)
    cache = load_cache
    cache[slug] = file_path
    save_cache(cache)
  end

  def self.generate_slug(title, _authors = nil, _upload_date = nil)
    base_slug = normalize_title(title)
    make_unique_slug(base_slug)
  end

  def self.normalize_title(title)
    slug = title.to_s.dup
    slug = slug.gsub(/[^\w\s-]/, '').gsub(/\s+/, '-').gsub(/-+/, '-')
    slug = slug.downcase.strip.gsub(/^-+|-+$/, '')
    slug = slug[0, 80] if slug.length > 80
    slug.empty? ? 'video' : slug
  end

  def self.make_unique_slug(base_slug)
    cache = load_cache
    return base_slug unless cache.key?(base_slug)

    counter = 1
    loop do
      candidate = "#{base_slug}-#{counter}"
      return candidate unless cache.key?(candidate)

      counter += 1
    end
  end

  def self.get_or_create_slug(file_path, title, authors = nil, upload_date = nil)
    # Check if we already have a slug for this file
    cache = load_cache
    existing_slug = cache.find { |_, path| path == file_path }&.first
    return existing_slug if existing_slug

    # Generate new slug
    slug = generate_slug(title, authors, upload_date)
    set_mapping(slug, file_path)
    slug
  end
end

# Processes JSON metadata files created by Downie for offline YouTube video viewing
# rubocop:disable Metrics/ClassLength
class DownieJSON
  attr_reader :file

  def initialize(file)
    @file = file
    should_update = !raw_json['lengthInSeconds'] || needs_thumbnail_update?
    update_json if should_update
  end

  def json
    @json ||= build_enhanced_json
  end

  private

  def build_enhanced_json
    enhanced_json_data
  rescue StandardError => e
    handle_json_processing_error(e)
  end

  def enhanced_json_data
    raw_json.merge(
      'progress' => progress,
      'url' => url,
      'cleanTitle' => clean_title,
      'channelUrl' => channel_url,
      'slug' => slug
    )
  end

  def handle_json_processing_error(error)
    puts "Error processing JSON for #{file}: #{error.message}"
    fallback_json_data
  end

  def fallback_json_data
    raw_json.merge(
      'progress' => 0,
      'url' => raw_json['url'],
      'cleanTitle' => raw_json['title'] || 'Unknown Title',
      'channelUrl' => nil,
      'slug' => SlugCache.generate_slug(raw_json['title'] || 'Unknown Title')
    )
  end

  public

  def marked_watched
    File.write file, raw_json.merge(
      'watched' => 'watched'
    ).to_json, encoding: 'UTF-8'
  end

  def launch_iina
    `open "#{offline_url}"`
  end

  private

  def needs_thumbnail_update?
    current_url = raw_json['previewImageURL']
    return false unless current_url&.include?('ytimg.com')

    local_thumbnail? || can_generate_thumbnail?
  end

  def local_thumbnail?
    thumbnail_extensions.any? { |ext| File.exist?(thumbnail_path_for_extension(ext)) }
  end

  def can_generate_thumbnail?
    File.exist?(video_path)
  end

  def thumbnail_extensions
    %w[.jpg .png .webp .mp4.png]
  end

  def thumbnail_path_for_extension(ext)
    if ext == '.mp4.png'
      "#{video_path}.png"
    else
      file.sub(/\.[^.]+$/, ext)
    end
  end

  def progress
    (start / raw_json['lengthInSeconds'].to_f * 100).to_i
  rescue StandardError
    0
  end

  def start
    md5_of_file_path = Digest::MD5.hexdigest video_path
    watch_later_path = "#{Dir.home}/Library/Application Support/com.colliderli.iina/watch_later"
    watch_later_file = "#{watch_later_path}/#{md5_of_file_path.upcase}"
    return 0 unless File.exist? watch_later_file

    start_line = File.readlines(watch_later_file).grep(/start=/).first
    return 0 unless start_line

    start_line.chomp.split('=').last.to_i
  end

  def update_json
    File.write file, raw_json.merge(
      'file' => file,
      'addedAtEpoch' => added_at_epoch,
      'offlineURL' => offline_url,
      'previewImageURL' => preview_image_url,
      'uploadDateEpoch' => upload_date_epoch,
      'length' => length,
      'lengthInSeconds' => length_in_seconds
    ).to_json, encoding: 'UTF-8'
  end

  def url
    return unless raw_json['url']

    uri = URI.parse raw_json['url']
    return unless uri.query

    query = URI.decode_www_form(uri.query).to_h
    query['t'] = start
    uri.query = URI.encode_www_form query
    uri.to_s
  end

  def length
    return raw_json['length'] if raw_json['length']

    seconds = length_in_seconds
    return '0:00' if seconds.zero?

    Time.at(seconds).utc.strftime(seconds < 3600 ? '%M:%S' : '%H:%M:%S')
  end

  def length_in_seconds
    return raw_json['lengthInSeconds'] if raw_json['lengthInSeconds']
    return 0 unless File.exist?(video_path)

    duration_from_ffprobe || duration_from_mdls || 0
  end

  def duration_from_ffprobe
    return unless system('which ffprobe > /dev/null 2>&1')

    cmd = 'ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1'
    duration = `#{cmd} "#{video_path}" 2>/dev/null`.chomp
    duration.to_f.to_i if duration.match?(/^\d+\.?\d*$/)
  end

  def duration_from_mdls
    duration = `mdls "#{video_path}" | grep Duration 2>/dev/null`.chomp
    duration.split('= ').last.to_i if duration.include?('=')
  end

  public

  def raw_json
    JSON.parse file_contents
  rescue JSON::ParserError => e
    puts "Warning: Invalid JSON in file #{file}: #{e.message}"
    {}
  end

  def offline_url
    return "iina://open?url=#{ERB::Util.url_encode video_path}" if File.exist? video_path

    ERB::Util.url_encode raw_json['url']
  end

  def video_path
    file.sub(/\.[^.]+$/, '.mp4')
  end

  def preview_image_url
    # Check for various image formats
    %w[.jpg .png .webp .mp4.png].each do |ext|
      expected_path = if ext == '.mp4.png'
                        "#{video_path}.png" # video.mp4.png
                      else
                        file.sub(/\.[^.]+$/, ext) # video.jpg, video.png, etc.
                      end
      return "/thumbnails/#{ERB::Util.url_encode expected_path.gsub DOWNLOAD_PATH, ''}" if File.exist? expected_path
    end

    # Try to generate thumbnail from video file if it exists
    return generate_preview_image if File.exist?(video_path)

    # Fallback to original URL or placeholder
    raw_json['previewImageURL'] || 'https://via.placeholder.com/480x270?text=No+Thumbnail'
  end

  def generate_preview_image
    return '/thumbnails/test_thumbnail.png' if ENV['YT_TEST_MODE']

    `qlmanage -t "#{video_path}" -s 512 -o "#{DOWNLOAD_PATH}"`
    file_name = "#{video_path.gsub(DOWNLOAD_PATH, '')}.png"
    "/thumbnails/#{ERB::Util.url_encode file_name}"
  end

  def added_at_epoch
    return 1_704_067_200 if ENV['YT_TEST_MODE']

    added = `GetFileInfo -d "#{file}"`.chomp
    return 0 if added.empty?

    time = Time.strptime added, '%m/%d/%Y %H:%M:%S'
    time.to_i
  end

  def upload_date_epoch
    date_string = raw_json['uploadDate'] || raw_json['prepareDate']
    return 0 unless date_string

    date = Date.parse date_string
    date.to_time.to_i
  end

  def file_contents
    File.read file, encoding: 'UTF-8'
  end

  def clean_title
    title = raw_json['title'] || ''
    authors = raw_json['authors'] || []

    # If we have authors and the title starts with the first author's name, clean it
    if !authors.empty? && title.start_with?(authors.first)
      # Remove "Channel Name - " from the beginning
      cleaned = title.sub(/^#{Regexp.escape(authors.first)}\s*-\s*/, '')
      return cleaned.empty? ? title : cleaned
    end

    title
  end

  def channel_url
    authors = raw_json['authors'] || []
    return nil if authors.empty? || !youtube_video?

    channel_name = authors.first

    # Check cache first
    cached_url = ChannelCache.get_url(channel_name)
    return cached_url if cached_url

    # Return search URL immediately to avoid blocking page load
    # The URL checking can be done lazily when user actually clicks
    "https://www.youtube.com/results?search_query=#{ERB::Util.url_encode(channel_name)}&sp=EgIQAg%253D%253D"
  end

  def check_and_cache_channel_url(channel_name)
    return if ChannelCache.get_url(channel_name) # Already cached

    # Try @username format first
    username = channel_name.gsub(/[^a-zA-Z0-9]/, '').downcase
    at_url = "https://www.youtube.com/@#{username}"

    if url_exists?(at_url)
      ChannelCache.set_url(channel_name, at_url)
      return at_url
    end

    # If @username 404s, cache the search URL instead
    search_url = "https://www.youtube.com/results?search_query=#{ERB::Util.url_encode(channel_name)}&sp=EgIQAg%253D%253D"
    ChannelCache.set_url(channel_name, search_url)
    search_url
  end

  def url_exists?(url)
    puts "Checking channel URL: #{url}" unless ENV['YT_TEST_MODE']
    uri = URI(url)
    response = Net::HTTP.get_response(uri)
    success = response.code != '404'
    puts "  -> #{response.code} #{success ? 'SUCCESS' : 'FAILED'}" unless ENV['YT_TEST_MODE']
    success
  rescue StandardError => e
    puts "  -> ERROR: #{e.message}" unless ENV['YT_TEST_MODE']
    false
  end

  def slug
    SlugCache.get_or_create_slug(file, clean_title, raw_json['authors'], raw_json['uploadDate'])
  end

  def youtube_video?
    url = raw_json['url'] || ''
    url.include?('youtube.com')
  end
end
# rubocop:enable Metrics/ClassLength

# Manages collection of YouTube video files with sorting and filtering capabilities
class YouTubeFiles
  def initialize(sort = nil, direction = nil, filter = nil)
    @sort = sort || 'downloadedAt'
    @direction = direction || 'desc'
    @filter = filter || 'all'
  end

  def json
    downie_files.map(&:json)
  end

  def downie_files
    files = json_files.map { |file| DownieJSON.new(file) }
    files = filter_files(files) if @filter != 'all'
    sorted = files.sort_by { |item| sort_value_for(item) }
    @direction == 'asc' ? sorted : sorted.reverse
  end

  private

  def sort_value_for(item)
    case @sort
    when 'downloadedAt'
      # Use prepareDate from JSON (actual download time), fallback to file creation time
      item.json['prepareDate'] ? Time.parse(item.json['prepareDate']) : File.birthtime(item.file)
    when 'recentlyPlayed'
      # Use file modification time (when metadata was last updated)
      File.mtime(item.file)
    else
      item.json[@sort] || item.json['prepareDate']
    end
  end

  def filter_files(files)
    files.select { |video| matches_filter?(video) }
  end

  def matches_filter?(video)
    case @filter
    when 'unwatched'
      unwatched?(video)
    when 'partial'
      partially_watched?(video)
    when 'watched'
      watched?(video)
    else
      true
    end
  end

  def unwatched?(video)
    progress = video.json['progress'] || 0
    progress.zero? && not_marked_watched?(video)
  end

  def partially_watched?(video)
    progress = video.json['progress'] || 0
    progress.positive? && progress < 95 && not_marked_watched?(video)
  end

  def watched?(video)
    !video.json['watched'].nil? && !video.json['watched'].empty?
  end

  def not_marked_watched?(video)
    video.json['watched'].nil? || video.json['watched'].empty?
  end

  def json_files
    Dir["#{DOWNLOAD_PATH}*.json"].reject do |file|
      file.end_with?('channel_cache.json') || file.end_with?('slug_cache.json')
    end
  end
end

set :environment, ENV['RACK_ENV'] || :development
set :bind, '0.0.0.0'
set :port, ENV['PORT'] || 7777
set :protection, host_authorization: { permitted_hosts: [] }

get '/' do
  if defined?(DATA)
    DATA.pos = END_OF_FILE
    template = DATA.read.force_encoding('UTF-8').split('@@channels')[0]
  else
    template = '<html><body>Test Mode</body></html>'
  end

  videos = YouTubeFiles.new params[:sort], params[:dir], params[:filter]

  # NOTE: Auto-thumbnail generation moved to avoid page load interference
  # Thumbnails are now generated on-demand in the preview_image_url method

  ERB.new(template).result binding
end

get '/assets/:file' do
  send_file "#{Dir.pwd}/yt-assets/#{params[:file]}", disposition: 'inline'
end

get '/thumbnails/:file' do
  send_file "#{DOWNLOAD_PATH}#{params[:file]}", disposition: 'inline'
end

get '/video-file/:file' do
  file_path = "#{DOWNLOAD_PATH}#{params[:file]}"

  # Security check - ensure file is in download directory and exists
  unless file_path.start_with?(DOWNLOAD_PATH) && File.exist?(file_path)
    status 404
    return 'Video file not found'
  end

  # Set proper content type for video files
  content_type 'video/mp4'
  send_file file_path, disposition: 'inline'
end

get '/channel-cache' do
  content_type :json
  ChannelCache.load_cache.to_json
end

get '/video' do
  file_path = params[:file]

  # Security check - ensure file is in download directory
  unless file_path&.start_with?(DOWNLOAD_PATH) && File.exist?(file_path)
    status 404
    return 'Video not found'
  end

  downie_json = DownieJSON.new(file_path)
  @video = downie_json.json
  @video_file_exists = File.exist?(@video['file'].sub('.json', '.mp4'))
  @start_time = downie_json.send(:start)

  if defined?(DATA)
    DATA.pos = END_OF_FILE
    template = DATA.read.force_encoding('UTF-8')
    show_template = template[/@@show\n(.*?)@@end_show/m, 1]
  else
    show_template = '<html><body>Show Test Mode</body></html>'
  end

  ERB.new(show_template).result binding
end

get '/watch' do
  slug = params[:v]

  # Look up file path from slug
  file_path = SlugCache.get_file_path(slug)

  # Security check - ensure file exists and is in download directory
  unless file_path&.start_with?(DOWNLOAD_PATH) && File.exist?(file_path)
    status 404
    return 'Video not found'
  end

  downie_json = DownieJSON.new(file_path)
  @video = downie_json.json
  @video_file_exists = File.exist?(@video['file'].sub('.json', '.mp4'))
  @start_time = downie_json.send(:start)

  if defined?(DATA)
    DATA.pos = END_OF_FILE
    template = DATA.read.force_encoding('UTF-8')
    show_template = template[/@@show\n(.*?)@@end_show/m, 1]
  else
    show_template = '<html><body>Show Test Mode</body></html>'
  end

  ERB.new(show_template).result binding
end

get '/channels' do
  channels_hash = ChannelCache.load_cache || {}
  # Sort by link type (search links first), then alphabetically by channel name
  @channels = channels_hash.sort_by do |channel_name, channel_url|
    is_search_link = !channel_url.include?('youtube.com/@')
    [is_search_link ? 0 : 1, channel_name.downcase]
  end

  if defined?(DATA)
    DATA.pos = END_OF_FILE
    template = DATA.read.force_encoding('UTF-8')
    channels_template = template[/@@channels\n(.*?)@@end_channels/m, 1]
  else
    channels_template = '<html><body>Channels Test Mode</body></html>'
  end

  ERB.new(channels_template).result binding
end

post '/channel-cache' do
  channel_name = params[:channel_name]
  channel_url = params[:channel_url]

  if channel_name && channel_url
    ChannelCache.set_url(channel_name, channel_url)
    redirect '/channels'
  else
    status 400
    { error: 'Missing channel_name or channel_url' }.to_json
  end
end

post '/check-channel/:channel_name' do
  content_type :json
  channel_name = params[:channel_name]
  downie_json = DownieJSON.new('')
  downie_json.instance_variable_set(:@file, '')
  downie_json.instance_variable_set(:@raw_json,
                                    { 'authors' => [channel_name], 'url' => 'https://youtube.com/watch?v=test' })

  url = downie_json.check_and_cache_channel_url(channel_name)
  { channel_name: channel_name, url: url }.to_json
end

def sync_to_iina_watch_later(file_path, current_time)
  watch_later_file = iina_watch_later_file_path(file_path)
  ensure_watch_later_directory_exists
  File.write(watch_later_file, "start=#{current_time}\n")
rescue StandardError
  # Silently fail if we can't write to IINA files
end

def iina_watch_later_file_path(file_path)
  video_path = file_path.sub('.json', '.mp4')
  md5_hash = Digest::MD5.hexdigest(video_path).upcase
  "#{iina_watch_later_directory}/#{md5_hash}"
end

def iina_watch_later_directory
  "#{Dir.home}/Library/Application Support/com.colliderli.iina/watch_later"
end

def ensure_watch_later_directory_exists
  FileUtils.mkdir_p(iina_watch_later_directory) unless File.exist?(iina_watch_later_directory)
end

def update_youtube_url_timestamp(youtube_url, current_time)
  uri = URI.parse(youtube_url)
  if uri.query
    query = URI.decode_www_form(uri.query).to_h
    query['t'] = current_time
    uri.query = URI.encode_www_form(query)
  else
    uri.query = "t=#{current_time}"
  end
  uri.to_s
end

def handle_progress_sync(file_path, params)
  downie_json = DownieJSON.new(file_path)
  raw_json = downie_json.send(:raw_json)
  current_progress = calculate_current_progress(downie_json, params, file_path)
  updated_json = build_updated_json(raw_json, current_progress, params)

  File.write(file_path, updated_json.to_json, encoding: 'UTF-8')
  [current_progress, updated_json, raw_json]
end

def calculate_current_progress(downie_json, params, file_path)
  if params[:web_progress] && params[:web_time]
    sync_to_iina_watch_later(file_path, params[:web_time].to_i)
    params[:web_progress].to_i
  else
    downie_json.send(:progress)
  end
end

def build_updated_json(raw_json, current_progress, params)
  updated_json = raw_json.merge('progress' => current_progress)
  if params[:web_time] && raw_json['url']
    updated_json['url'] = update_youtube_url_timestamp(raw_json['url'], params[:web_time].to_i)
  end
  updated_json
end

post '/sync-progress' do
  content_type :json
  file_path = params[:file]

  unless file_path && File.exist?(file_path)
    status 400
    return { error: 'File not found' }.to_json
  end

  begin
    current_progress, updated_json, raw_json = handle_progress_sync(file_path, params)

    response = { success: true, progress: current_progress }
    response[:youtube_url] = updated_json['url'] if updated_json['url'] != raw_json['url']
    response.to_json
  rescue StandardError => e
    status 500
    { error: "Failed to sync progress: #{e.message}" }.to_json
  end
end

delete '/channel-cache/:channel_name' do
  cache = ChannelCache.load_cache
  cache.delete(params[:channel_name])
  ChannelCache.save_cache(cache)
  redirect '/channels'
end

post '/mark-watched' do
  content_type :json
  file_path = params[:file]

  unless file_path && File.exist?(file_path)
    status 400
    return { error: 'File not found' }.to_json
  end

  downie_json = DownieJSON.new(file_path)
  raw_json = downie_json.send(:raw_json)

  # Get YouTube URL with timestamp at the end
  youtube_url_with_timestamp = create_end_timestamp_url(raw_json)

  # Mark as watched locally
  downie_json.marked_watched

  response = { success: true }
  response[:youtube_url] = youtube_url_with_timestamp if youtube_url_with_timestamp
  response.to_json
end

delete '/video' do
  content_type :json
  file_path = params[:file]

  unless file_path && File.exist?(file_path)
    status 400
    return { error: 'File not found' }.to_json
  end

  downie_json = DownieJSON.new(file_path)
  raw_json = downie_json.send(:raw_json)

  # Get YouTube URL with timestamp at the end
  youtube_url_with_timestamp = create_end_timestamp_url(raw_json)

  # Delete all files
  delete_video_files(file_path)

  response = { success: true }
  response[:youtube_url] = youtube_url_with_timestamp if youtube_url_with_timestamp
  response.to_json
end

def create_end_timestamp_url(raw_json)
  youtube_url = raw_json['url']
  length_in_seconds = raw_json['lengthInSeconds'] || 0

  return nil unless youtube_url && length_in_seconds.positive?

  separator = youtube_url.include?('?') ? '&' : '?'
  "#{youtube_url}#{separator}t=#{length_in_seconds - 5}"
end

def delete_video_files(file_path)
  video_path = file_path.sub(/\.json$/, '.mp4')
  thumbnail_patterns = %w[.jpg .png .webp .mp4.png]

  File.delete(file_path)
  FileUtils.rm_f(video_path)

  thumbnail_patterns.each do |ext|
    thumb_path = ext == '.mp4.png' ? "#{video_path}.png" : file_path.sub(/\.json$/, ext)
    FileUtils.rm_f(thumb_path)
  end
end

def fetch_assets
  return if Dir.exist? 'yt-assets'

  FileUtils.mkdir 'yt-assets'
  if ENV['YT_TEST_MODE']
    # In test mode, just create a dummy file
    File.write('yt-assets/tailwind-browser.js', '// test mode')
  else
    `cd yt-assets; curl -o tailwind-browser.js https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4`
  end
end

`which iina`
unless $CHILD_STATUS.success?
  warn 'IINA not found. Please run `brew install --cask iina` to proceed.'
  exit 1
end

unless ENV['YT_TEST_MODE']
  fetch_assets
  Sinatra::Application.run!
end

__END__
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Eric's Offline YouTube</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='h-5 w-5' viewBox='0 0 20 20' fill='red'%3E%3Cpath fill-rule='evenodd' d='M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z' clip-rule='evenodd' /%3E%3C/svg%3E" type="image/svg+xml" />
  <script src="./assets/tailwind-browser.js"></script>
  <style>
    .progress-bar {
      background: linear-gradient(to right, #ff0000 var(--progress), transparent var(--progress));
    }
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .line-clamp-3 {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .video-card.keyboard-selected {
      outline: 2px solid #ef4444;
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2);
      transform: translateY(-2px);
      transition: all 0.2s ease;
    }
    .video-card.keyboard-selected:hover {
      outline: 2px solid #dc2626;
      box-shadow: 0 0 0 4px rgba(220, 38, 38, 0.3);
    }
    .video-card a.block:focus {
      outline: none;
    }
  </style>
</head>
<body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-white transition-colors duration-200">
  <!-- Header -->
  <header class="bg-gray-100 dark:bg-gray-900 py-3 px-4 border-b border-gray-200 dark:border-gray-700">
    <!-- Mobile Header -->
    <div class="md:hidden">
      <div class="flex items-center justify-between mb-3">
        <h1 class="text-lg font-bold text-red-500">Offline YouTube</h1>
        <div class="flex items-center space-x-2">
          <a href="/channels" class="text-gray-600 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition-colors text-xs">
            Manage Channels
          </a>
          <a href="https://www.youtube.com" target="_blank" class="text-red-500 hover:text-red-400">
            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
              <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
            </svg>
          </a>
        </div>
      </div>
      <div class="flex items-center justify-between">
        <div class="text-xs text-gray-600 dark:text-gray-400">
          <%= `ls ~/Downloads/YouTube/*.mp4 | wc -l` %> videos / <%= `du -h ~/Downloads/YouTube/ | tail -1 | awk '{print $1}'` %>
        </div>
        <!-- Mobile Search -->
        <div class="flex-1 ml-3">
          <div class="relative">
            <input id="search-input-mobile" type="text" placeholder="Search..."
              class="w-full bg-white dark:bg-gray-700 text-gray-900 dark:text-white px-3 py-2 pl-8 text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-red-500 border border-gray-300 dark:border-gray-600">
            <svg class="w-4 h-4 text-gray-400 absolute left-2.5 top-1/2 transform -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Desktop Header -->
    <div class="hidden md:flex items-center justify-between">
      <div class="flex items-center space-x-4">
        <h1 class="text-xl font-bold text-red-500">Offline YouTube</h1>
        <div class="text-sm text-gray-600 dark:text-gray-400">
          <%= `ls ~/Downloads/YouTube/*.mp4 | wc -l` %> videos /
          <%= `du -h ~/Downloads/YouTube/ | tail -1 | awk '{print $1}'` %>
        </div>
      </div>

      <!-- Desktop Search Bar -->
      <div class="max-w-xl flex-1 mx-8">
        <div class="relative">
          <input id="search-input" type="text" placeholder="Search videos..."
            class="w-full bg-white dark:bg-gray-700 text-gray-900 dark:text-white px-4 py-2 pl-10 rounded-full focus:outline-none focus:ring-2 focus:ring-red-500 border border-gray-300 dark:border-gray-600">
          <svg class="w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
          </svg>
        </div>
      </div>

      <div class="flex items-center space-x-4">
        <a href="/channels" class="text-gray-600 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition-colors text-sm">
          Manage Channels
        </a>
        <a href="https://www.youtube.com" target="_blank" class="text-red-500 hover:text-red-400">
          <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
          </svg>
        </a>
      </div>
    </div>
  </header>

  <!-- Sort Bar -->
  <div class="bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 py-3 px-4">
    <!-- Mobile Sort Bar -->
    <div class="md:hidden">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-base font-semibold text-gray-900 dark:text-white">Videos</h2>
        <div class="text-xs text-gray-500 dark:text-gray-200">
          <span id="video-count-mobile"><%= videos&.json&.length || 0 %></span> videos
        </div>
      </div>
      <div class="flex items-center space-x-3">
        <div class="flex items-center flex-1">
          <div class="relative flex-1">
            <button type="button" class="sort-dropdown-trigger grid cursor-default grid-cols-1 rounded-md bg-white dark:bg-gray-800 py-3 pr-3 pl-3 text-left text-gray-900 dark:text-white outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500 text-sm w-full" data-dropdown="sort-mobile">
              <span class="col-start-1 row-start-1 truncate pr-4"><%= params[:sort] == 'recentlyPlayed' ? 'Played' : (params[:sort] == 'uploadDateEpoch' ? 'Created' : 'Downloaded') %></span>
              <svg class="col-start-1 row-start-1 w-3 h-3 self-center justify-self-end text-gray-500 dark:text-gray-400" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M5.22 10.22a.75.75 0 0 1 1.06 0L8 11.94l1.72-1.72a.75.75 0 1 1 1.06 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0l-2.25-2.25a.75.75 0 0 1 0-1.06ZM10.78 5.78a.75.75 0 0 1-1.06 0L8 4.06 6.28 5.78a.75.75 0 0 1-1.06-1.06l2.25-2.25a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
              </svg>
            </button>
            <ul class="dropdown-menu absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white dark:bg-gray-800 py-1 text-sm shadow-lg ring-1 ring-black/5 dark:ring-white/10 focus:outline-hidden hidden" data-dropdown="sort-mobile">
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="downloadedAt">
                <span class="block truncate">Downloaded</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'downloadedAt' || params[:sort].nil? %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="recentlyPlayed">
                <span class="block truncate">Played</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'recentlyPlayed' %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="uploadDateEpoch">
                <span class="block truncate">Created</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'uploadDateEpoch' %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
            </ul>
          </div>
          <button id="sort-direction-mobile" class="sort-direction px-3 py-3 bg-white dark:bg-gray-800 outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 rounded-md transition-colors text-sm grid place-items-center focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500" title="Toggle sort direction">
            <svg class="sort-asc w-3 h-3 text-gray-500 dark:text-gray-200 <%= 'hidden' if params[:dir] == 'asc' %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
            </svg>
            <svg class="sort-desc w-3 h-3 text-gray-500 dark:text-gray-200 <%= 'hidden' unless params[:dir] == 'asc' %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h9m5-4v12m0 0l-4-4m4 4l4-4"/>
            </svg>
          </button>
        </div>

        <div class="flex items-center flex-1">
          <div class="relative flex-1">
            <button type="button" class="filter-dropdown-trigger grid cursor-default grid-cols-1 rounded-md bg-white dark:bg-gray-800 py-3 pr-3 pl-3 text-left text-gray-900 dark:text-white outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500 text-sm w-full" data-dropdown="filter-mobile">
              <span class="col-start-1 row-start-1 truncate pr-4"><%= params[:filter] == 'unwatched' ? 'Unwatched' : (params[:filter] == 'partial' ? 'Partial' : (params[:filter] == 'watched' ? 'Watched' : 'All')) %></span>
              <svg class="col-start-1 row-start-1 w-3 h-3 self-center justify-self-end text-gray-500 dark:text-gray-400" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M5.22 10.22a.75.75 0 0 1 1.06 0L8 11.94l1.72-1.72a.75.75 0 1 1 1.06 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0l-2.25-2.25a.75.75 0 0 1 0-1.06ZM10.78 5.78a.75.75 0 0 1-1.06 0L8 4.06 6.28 5.78a.75.75 0 0 1-1.06-1.06l2.25-2.25a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
              </svg>
            </button>
            <ul class="dropdown-menu absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white dark:bg-gray-800 py-1 text-xs shadow-lg ring-1 ring-black/5 dark:ring-white/10 focus:outline-hidden hidden" data-dropdown="filter-mobile">
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="all">
                <span class="block truncate">All</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'all' || params[:filter].nil? %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="unwatched">
                <span class="block truncate">Unwatched</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'unwatched' %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="partial">
                <span class="block truncate">Partial</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'partial' %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
              <li class="dropdown-item relative cursor-pointer py-2 pr-8 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="watched">
                <span class="block truncate">Watched</span>
                <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-2 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'watched' %>">
                  <svg class="w-3 h-3" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                  </svg>
                </span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Desktop Sort Bar -->
    <div class="hidden md:flex items-center justify-between">
      <div class="flex items-center space-x-4">
        <h2 class="text-lg font-semibold text-gray-900 dark:text-white">Videos</h2>
      </div>
      <div class="flex items-center space-x-6">
          <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-600 dark:text-gray-400">Filter:</span>
            <div class="relative">
              <button type="button" class="filter-dropdown-trigger grid cursor-default grid-cols-1 rounded-md bg-white dark:bg-gray-800 py-1.5 pr-2 pl-3 text-left text-gray-900 dark:text-white outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500 text-sm min-w-44" data-dropdown="filter-desktop">
                <span class="col-start-1 row-start-1 truncate pr-6"><%= params[:filter] == 'unwatched' ? 'Unwatched' : (params[:filter] == 'partial' ? 'Partially Played' : (params[:filter] == 'watched' ? 'Watched' : 'All Videos')) %></span>
                <svg class="col-start-1 row-start-1 w-4 h-4 self-center justify-self-end text-gray-500 dark:text-gray-400" viewBox="0 0 16 16" fill="currentColor">
                  <path fill-rule="evenodd" d="M5.22 10.22a.75.75 0 0 1 1.06 0L8 11.94l1.72-1.72a.75.75 0 1 1 1.06 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0l-2.25-2.25a.75.75 0 0 1 0-1.06ZM10.78 5.78a.75.75 0 0 1-1.06 0L8 4.06 6.28 5.78a.75.75 0 0 1-1.06-1.06l2.25-2.25a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
                </svg>
              </button>
              <ul class="dropdown-menu absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white dark:bg-gray-800 py-1 text-sm shadow-lg ring-1 ring-black/5 dark:ring-white/10 focus:outline-hidden hidden" data-dropdown="filter-desktop">
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="all">
                  <span class="block truncate">All Videos</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'all' || params[:filter].nil? %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="unwatched">
                  <span class="block truncate">Unwatched</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'unwatched' %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="partial">
                  <span class="block truncate">Partially Played</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'partial' %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="watched">
                  <span class="block truncate">Watched</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:filter] == 'watched' %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
              </ul>
            </div>
          </div>

          <!-- Divider -->
          <div class="h-6 w-px bg-gray-300 dark:bg-gray-600"></div>

          <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-600 dark:text-gray-400">Sort by:</span>
            <div class="relative">
              <button type="button" class="sort-dropdown-trigger grid cursor-default grid-cols-1 rounded-md bg-white dark:bg-gray-800 py-1.5 pr-2 pl-3 text-left text-gray-900 dark:text-white outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500 text-sm min-w-48" data-dropdown="sort-desktop">
                <span class="col-start-1 row-start-1 truncate pr-6"><%= params[:sort] == 'recentlyPlayed' ? 'Recently Played' : (params[:sort] == 'uploadDateEpoch' ? 'Recently Created' : 'Recently Downloaded') %></span>
                <svg class="col-start-1 row-start-1 w-4 h-4 self-center justify-self-end text-gray-500 dark:text-gray-400" viewBox="0 0 16 16" fill="currentColor">
                  <path fill-rule="evenodd" d="M5.22 10.22a.75.75 0 0 1 1.06 0L8 11.94l1.72-1.72a.75.75 0 1 1 1.06 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0l-2.25-2.25a.75.75 0 0 1 0-1.06ZM10.78 5.78a.75.75 0 0 1-1.06 0L8 4.06 6.28 5.78a.75.75 0 0 1-1.06-1.06l2.25-2.25a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
                </svg>
              </button>
              <ul class="dropdown-menu absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white dark:bg-gray-800 py-1 text-sm shadow-lg ring-1 ring-black/5 dark:ring-white/10 focus:outline-hidden hidden" data-dropdown="sort-desktop">
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="downloadedAt">
                  <span class="block truncate">Recently Downloaded</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'downloadedAt' || params[:sort].nil? %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="recentlyPlayed">
                  <span class="block truncate">Recently Played</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'recentlyPlayed' %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
                <li class="dropdown-item relative cursor-pointer py-2 pr-9 pl-3 text-gray-900 dark:text-white select-none hover:bg-gray-100 dark:hover:bg-gray-700" data-value="uploadDateEpoch">
                  <span class="block truncate">Recently Created</span>
                  <span class="checkmark absolute inset-y-0 right-0 flex items-center pr-4 text-blue-600 dark:text-blue-400 <%= 'hidden' unless params[:sort] == 'uploadDateEpoch' %>">
                    <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z" clip-rule="evenodd" />
                    </svg>
                  </span>
                </li>
              </ul>
            </div>
            <button id="sort-direction-desktop" class="sort-direction ml-2 px-3 py-1.5 bg-white dark:bg-gray-800 outline-1 -outline-offset-1 outline-gray-300 dark:outline-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 rounded-md transition-colors text-sm grid place-items-center focus:outline-2 focus:-outline-offset-2 focus:outline-blue-500" title="Toggle sort direction">
              <svg class="sort-asc w-4 h-4 text-gray-500 dark:text-gray-400 <%= 'hidden' if params[:dir] == 'asc' %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
              </svg>
              <svg class="sort-desc w-4 h-4 text-gray-500 dark:text-gray-400 <%= 'hidden' unless params[:dir] == 'asc' %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h9m5-4v12m0 0l-4-4m4 4l4-4"/>
              </svg>
            </button>
          </div>
        </div>
      <div class="text-sm text-gray-500 dark:text-gray-400">
        Showing <span id="video-count-desktop"><%= videos&.json&.length || 0 %></span> videos
      </div>
    </div>
  </div>

  <!-- Video Grid -->
  <main class="px-4 py-6 md:px-6 md:py-8">
    <div id="video-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4 md:gap-6">
      <% (videos&.json || []).each do |video| %>
        <div class="video-card bg-white dark:bg-gray-800 rounded-lg overflow-hidden hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors shadow-lg">
          <!-- Thumbnail -->
          <div class="relative aspect-video bg-white dark:bg-gray-100 group">
            <a href="/watch?v=<%= video['slug'] %>" class="block w-full h-full">
              <img src="<%= video['previewImageURL'] %>"
                alt="<%= video['title'] %>"
                class="w-full h-full object-cover <%= video['watched'].nil? || video['watched']&.empty? ? '' : 'opacity-60' %>">
            </a>

            <!-- Hover overlay -->
            <div class="absolute inset-0 bg-black opacity-0 group-hover:opacity-60 transition-opacity duration-200 pointer-events-none z-10 flex items-center justify-center">
              <svg class="w-16 h-16 text-white opacity-0 group-hover:opacity-90 transition-opacity duration-200" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </div>

            <!-- Duration -->
            <div class="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white text-sm px-2 py-1 rounded">
              <%= video['length'] %>
            </div>

            <!-- Progress Bar -->
            <% progress_value = video['watched'] ? 100 : (video['progress'] || 0) %>
            <div class="absolute bottom-0 left-0 right-0 h-1 bg-gray-300 dark:bg-gray-600">
              <div class="h-full bg-red-500" style="width: <%= progress_value %>%"></div>
            </div>
          </div>

          <!-- Video Info -->
          <div class="p-4">
            <h3 class="video-title text-base font-medium line-clamp-2 mb-2 text-gray-900 dark:text-white">
              <a href="/watch?v=<%= video['slug'] %>" class="hover:text-red-500 transition-colors">
                <%= video['cleanTitle'] || video['title'] %>
              </a>
            </h3>
            <div class="text-sm text-gray-600 dark:text-gray-400 space-y-2">
              <div class="video-author">
                <% if video['channelUrl'] %>
                  <a href="<%= video['channelUrl'] %>" target="_blank" class="hover:text-red-500 transition-colors">
                    <%= video['authors']&.join(', ') %>
                  </a>
                <% else %>
                  <%= video['authors']&.join(', ') %>
                <% end %>
              </div>
              <div class="flex items-center justify-between">
                <time class="relative-time" datetime="<%= video['uploadDateEpoch'] %>" title="<%= Time.at(video['uploadDateEpoch']).strftime('%B %d, %Y at %I:%M %p CT') if video['uploadDateEpoch'] %>">
                  <%= video['uploadDate'] %>
                </time>
                <div class="flex space-x-3">
                  <button class="hover:text-blue-500 text-lg iina-play-btn cursor-pointer" title="Play in IINA" data-iina-url="<%= video['offlineURL'] %>">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.68L9.54 5.98C8.87 5.55 8 6.03 8 6.82z"/>
                    </svg>
                  </button>
                  <button class="hover:text-green-500 text-lg mark-watched-btn cursor-pointer" title="Mark watched" data-file="<%= ERB::Util.url_encode(video['file']) %>"></button>
                  <button class="hover:text-red-500 text-lg delete-btn cursor-pointer" title="Delete" data-file="<%= ERB::Util.url_encode(video['file']) %>">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      <% end %>

      <!-- YouTube Search Card -->
      <div id="youtube-search-card" class="video-card bg-white dark:bg-gray-800 rounded-lg overflow-hidden hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors shadow-lg border-2 border-dashed border-gray-300 dark:border-gray-600 hidden">
        <!-- YouTube Icon Thumbnail -->
        <div class="relative aspect-video bg-red-50 dark:bg-red-900/20 flex items-center justify-center">
          <svg class="w-20 h-20 text-red-500" fill="currentColor" viewBox="0 0 24 24">
            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
          </svg>
        </div>

        <!-- Card Info -->
        <div class="p-4 text-center">
          <h3 class="text-base font-medium mb-2 text-gray-900 dark:text-white">
            <span id="youtube-card-text">Search on YouTube for more videos</span>
          </h3>
          <a id="youtube-search-link" href="https://www.youtube.com/results?search_query=" target="_blank"
            class="inline-flex items-center px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm rounded-lg transition-colors">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 24 24">
              <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
            </svg>
            Search on YouTube
          </a>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Hide IINA buttons on remote access (non-localhost)
    const isRemote = !['localhost', '127.0.0.1', 'e14.local'].includes(window.location.hostname);
    if (isRemote) {
      document.querySelectorAll('.iina-play-btn').forEach(btn => btn.style.display = 'none');
    }

    // Search functionality
    const searchInput = document.getElementById('search-input');
    const searchInputMobile = document.getElementById('search-input-mobile');
    const videoGrid = document.getElementById('video-grid');
    const youtubeSearchCard = document.getElementById('youtube-search-card');
    const youtubeSearchLink = document.getElementById('youtube-search-link');
    const videoCards = document.querySelectorAll('.video-card:not(#youtube-search-card)');

    function handleSearch(e) {
      const query = e.target.value.toLowerCase().trim();
      const youtubeCardText = document.getElementById('youtube-card-text');
      const videoCountDesktop = document.getElementById('video-count-desktop');
      const videoCountMobile = document.getElementById('video-count-mobile');

      if (!query) {
        // Show all videos when search is empty
        videoCards.forEach(card => card.style.display = 'block');
        youtubeSearchCard.classList.add('hidden');
        videoCountDesktop.textContent = videoCards.length;
        videoCountMobile.textContent = videoCards.length;
        return;
      }

      let visibleCount = 0;

      videoCards.forEach(card => {
        const title = card.querySelector('.video-title').textContent.toLowerCase();
        const author = card.querySelector('.video-author').textContent.toLowerCase();

        const matches = title.includes(query) || author.includes(query);
        card.style.display = matches ? 'block' : 'none';

        if (matches) visibleCount++;
      });

      // Update video count
      videoCountDesktop.textContent = visibleCount;
      videoCountMobile.textContent = visibleCount;

      // Show YouTube search card and update link
      youtubeSearchCard.classList.remove('hidden');
      youtubeSearchLink.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;

      if (visibleCount === 0) {
        youtubeCardText.textContent = 'No videos found in your collection.';
      } else {
        youtubeCardText.textContent = `Search "${query}" on YouTube for more videos`;
      }

      // Sync search inputs
      if (e.target.id === 'search-input') {
        searchInputMobile.value = query;
      } else {
        searchInput.value = query;
      }
    }

    // Add event listeners to both search inputs
    searchInput.addEventListener('input', handleSearch);
    searchInputMobile.addEventListener('input', handleSearch);

    // Add Enter key listeners to focus first video
    searchInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        focusFirstVideo();
      }
    });

    searchInputMobile.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        focusFirstVideo();
      }
    });

    // Keyboard navigation for video grid using browser focus
    let gridColumns = 1;

    function getVisibleVideoCards() {
      const visibleCards = Array.from(videoCards).filter(card => {
        // Check both hidden class and display style (for search filtering)
        return !card.classList.contains('hidden') &&
              window.getComputedStyle(card).display !== 'none';
      });

      const youtubeCard = document.getElementById('youtube-search-card');

      // Add YouTube search card if visible
      if (youtubeCard && !youtubeCard.classList.contains('hidden')) {
        visibleCards.push(youtubeCard);
      }

      return visibleCards;
    }

    function getFirstFocusableElementInCard(card) {
      const selector = 'a[href], button:not([disabled])';
      const focusableElements = card.querySelectorAll(selector);
      return focusableElements.length > 0 ? focusableElements[0] : null;
    }

    function updateGridColumns() {
      const gridContainer = document.getElementById('video-grid');
      const computedStyle = window.getComputedStyle(gridContainer);
      const columns = computedStyle.getPropertyValue('grid-template-columns').split(' ').length;
      gridColumns = columns;
    }

    function getCardGridPosition(card) {
      const visibleCards = getVisibleVideoCards();
      const cardIndex = visibleCards.indexOf(card);
      return {
        row: Math.floor(cardIndex / gridColumns),
        col: cardIndex % gridColumns
      };
    }

    function getCurrentCard() {
      const activeElement = document.activeElement;
      if (!activeElement) return null;
      return activeElement.closest('.video-card');
    }

    function updateCardHighlight(targetCard) {
      // Remove previous selection
      document.querySelectorAll('.video-card.keyboard-selected').forEach(card => {
        card.classList.remove('keyboard-selected');
      });

      // Add selection to target card
      if (targetCard) {
        targetCard.classList.add('keyboard-selected');
      }
    }

    function focusFirstVideo() {
      const visibleCards = getVisibleVideoCards();
      if (visibleCards.length > 0) {
        const firstElement = getFirstFocusableElementInCard(visibleCards[0]);
        if (firstElement) {
          firstElement.focus();
          updateCardHighlight(visibleCards[0]);
        }
      }
    }

    function navigateGrid(direction) {
      let currentCard = getCurrentCard();
      const visibleCards = getVisibleVideoCards();

      if (visibleCards.length === 0) return;

      let targetCard = null;
      let currentIndex = currentCard ? visibleCards.indexOf(currentCard) : -1;

      // If we lost focus (currentCard is null or not found), try to find the highlighted card
      if (currentIndex < 0) {
        const highlightedCard = document.querySelector('.video-card.keyboard-selected');
        if (highlightedCard && visibleCards.includes(highlightedCard)) {
          currentIndex = visibleCards.indexOf(highlightedCard);
          currentCard = highlightedCard;
        }
      }

      // If still no valid position, start from first card
      if (currentIndex < 0) {
        currentIndex = 0;
        currentCard = visibleCards[0];
      }

      switch(direction) {
        case 'right':
        case 'l':
          if (currentIndex >= 0 && currentIndex < visibleCards.length - 1) {
            targetCard = visibleCards[currentIndex + 1];
          } else if (currentIndex < 0) {
            targetCard = visibleCards[0];
          }
          // If at last card, don't move
          break;
        case 'left':
        case 'h':
          if (currentIndex > 0) {
            targetCard = visibleCards[currentIndex - 1];
          } else if (currentIndex < 0) {
            targetCard = visibleCards[0];
          }
          // If at first card, don't move
          break;
        case 'down':
        case 'j':
          const currentPos = getCardGridPosition(currentCard);
          const targetRow = currentPos.row + 1;
          const targetCol = currentPos.col;
          const targetIndex = (targetRow * gridColumns) + targetCol;

          if (targetIndex < visibleCards.length) {
            targetCard = visibleCards[targetIndex];
          } else {
            // If target position doesn't exist, try last card in that row
            const lastInRow = Math.min((targetRow * gridColumns) + (gridColumns - 1), visibleCards.length - 1);
            if (lastInRow > currentIndex) {
              targetCard = visibleCards[lastInRow];
            }
          }
          break;
        case 'up':
        case 'k':
          const currentPosUp = getCardGridPosition(currentCard);
          const targetRowUp = currentPosUp.row - 1;

          if (targetRowUp >= 0) {
            const targetCol = currentPosUp.col;
            const targetIndex = (targetRowUp * gridColumns) + targetCol;

            if (targetIndex >= 0 && targetIndex < visibleCards.length) {
              targetCard = visibleCards[targetIndex];
            } else {
              // If target position doesn't exist, try last card in that row
              const lastInRow = Math.min((targetRowUp * gridColumns) + (gridColumns - 1), visibleCards.length - 1);
              if (lastInRow >= 0) {
                targetCard = visibleCards[lastInRow];
              }
            }
          }
          break;
      }

      if (targetCard) {
        const firstElement = getFirstFocusableElementInCard(targetCard);
        if (firstElement) {
          firstElement.focus();
          updateCardHighlight(targetCard);

          // Scroll into view
          firstElement.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'nearest'
          });
        }
      } else if (currentIndex < 0 && visibleCards.length > 0) {
        // If we couldn't find a target and have no current position, focus first video
        focusFirstVideo();
      }
    }


    // Helper functions for keyboard shortcuts
    function clickButtonInCurrentCard(selector) {
      const currentCard = getCurrentCard();
      if (currentCard) {
        const button = currentCard.querySelector(selector);
        if (button) {
          button.click();
        }
      }
    }

    function clickLinkInCurrentCard(selector) {
      const currentCard = getCurrentCard();
      if (currentCard) {
        const link = currentCard.querySelector(selector);
        if (link) {
          link.click();
        }
      }
    }

    // Global keyboard event listener
    document.addEventListener('keydown', function(e) {
      // Skip if user is typing in an input field
      const activeElement = document.activeElement;
      if (activeElement && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.contentEditable === 'true'
      )) {
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'h':
        case 'arrowleft':
          e.preventDefault();
          navigateGrid('h');
          break;
        case 'j':
        case 'arrowdown':
          e.preventDefault();
          navigateGrid('j');
          break;
        case 'k':
        case 'arrowup':
          e.preventDefault();
          navigateGrid('k');
          break;
        case 'l':
        case 'arrowright':
          e.preventDefault();
          navigateGrid('l');
          break;
        case 'escape':
          // Clear search and focus first video
          e.preventDefault();
          searchInput.value = '';
          searchInputMobile.value = '';
          handleSearch({ target: searchInput });
          focusFirstVideo();
          break;
        case '/':
          // Focus search input
          e.preventDefault();
          const isMobile = window.innerWidth < 768;
          if (isMobile) {
            searchInputMobile.focus();
          } else {
            searchInput.focus();
          }
          break;
        case 'i':
          // Open in IINA
          e.preventDefault();
          clickButtonInCurrentCard('.iina-play-btn');
          break;
        case 'c':
          // Open channel
          e.preventDefault();
          clickLinkInCurrentCard('a[href*="youtube.com"]');
          break;
        case 'w':
          // Mark watched
          e.preventDefault();
          clickButtonInCurrentCard('.mark-watched-btn');
          break;
        case 'd':
          // Delete video
          e.preventDefault();
          clickButtonInCurrentCard('.delete-btn');
          break;
        case 'Y':
          // Open youtube.com
          e.preventDefault();
          if (e.shiftKey) {
            // Open in new tab
            window.open('https://www.youtube.com', '_blank');
          } else {
            const youtubeLink = document.querySelector('a[href="https://www.youtube.com"]');
            if (youtubeLink) {
              youtubeLink.click();
            }
          }
          break;
      }
    });

    // Focus first video on page load
    window.addEventListener('load', function() {
      updateGridColumns();
      focusFirstVideo();
    });

    // Update grid columns on resize
    window.addEventListener('resize', function() {
      updateGridColumns();
    });

    // Focus first video after search
    const originalHandleSearch = handleSearch;
    handleSearch = function(e) {
      originalHandleSearch(e);
      // Small delay to ensure DOM updates are complete
      setTimeout(() => {
        updateGridColumns();
        focusFirstVideo();
      }, 10);
    };

    // Maintain card highlighting only when thumbnail link is focused
    document.addEventListener('focusin', function(e) {
      const focusedCard = e.target.closest('.video-card');

      // Only highlight card if focus is on the thumbnail link (a.block)
      if (focusedCard && e.target.matches('a.block')) {
        updateCardHighlight(focusedCard);
      } else {
        // Clear highlighting when focus moves to other elements
        updateCardHighlight(null);
      }
    });

    // Convert timestamps to relative time
    function timeAgo(timestamp) {
      const now = Math.floor(Date.now() / 1000);
      const diff = now - timestamp;

      if (diff < 60) return 'Just now';
      if (diff < 3600) return Math.floor(diff / 60) + ' minutes ago';
      if (diff < 86400) return Math.floor(diff / 3600) + ' hours ago';
      if (diff < 2592000) return Math.floor(diff / 86400) + ' days ago';
      if (diff < 31536000) return Math.floor(diff / 2592000) + ' months ago';
      return Math.floor(diff / 31536000) + ' years ago';
    }

    function updateRelativeTimes() {
      document.querySelectorAll('.relative-time').forEach(timeEl => {
        const timestamp = parseInt(timeEl.getAttribute('datetime'));
        if (timestamp) {
          timeEl.textContent = timeAgo(timestamp);
        }
      });
    }

    // Handle search parameter from URL (when coming from show view)
    const urlParams = new URLSearchParams(window.location.search);
    const searchParam = urlParams.get('search');
    if (searchParam) {
      searchInput.value = searchParam;
      // Trigger the search
      searchInput.dispatchEvent(new Event('input'));
    }

    // Update relative times on load and every minute
    updateRelativeTimes();
    setInterval(updateRelativeTimes, 60000);

    // Custom dropdown functionality
    document.querySelectorAll('.sort-dropdown-trigger, .filter-dropdown-trigger').forEach(function(trigger) {
      trigger.addEventListener('click', function() {
        const dropdownId = this.getAttribute('data-dropdown');
        const menu = document.querySelector(`[data-dropdown="${dropdownId}"].dropdown-menu`);

        // Close all other dropdowns
        document.querySelectorAll('.dropdown-menu').forEach(function(otherMenu) {
          if (otherMenu !== menu) {
            otherMenu.classList.add('hidden');
          }
        });

        // Toggle this dropdown
        menu.classList.toggle('hidden');
      });
    });

    // Handle dropdown item clicks
    document.querySelectorAll('.dropdown-item').forEach(function(item) {
      item.addEventListener('click', function() {
        const value = this.getAttribute('data-value');
        const dropdownId = this.closest('.dropdown-menu').getAttribute('data-dropdown');
        const currentParams = new URLSearchParams(window.location.search);

        if (dropdownId.includes('sort')) {
          currentParams.set('sort', value);
        } else if (dropdownId.includes('filter')) {
          if (value === 'all') {
            currentParams.delete('filter');
          } else {
            currentParams.set('filter', value);
          }
        }

        window.location.search = currentParams.toString();
      });
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', function(event) {
      if (!event.target.closest('.sort-dropdown-trigger, .filter-dropdown-trigger') && !event.target.closest('.dropdown-menu')) {
        document.querySelectorAll('.dropdown-menu').forEach(function(menu) {
          menu.classList.add('hidden');
        });
      }
    });

    // Sort direction toggle
    document.querySelectorAll('.sort-direction').forEach(function(element) {
      element.addEventListener('click', function() {
        const currentParams = new URLSearchParams(window.location.search);
        const currentDir = currentParams.get('dir') || 'desc';
        const newDir = currentDir === 'desc' ? 'asc' : 'desc';
        currentParams.set('dir', newDir);
        window.location.search = currentParams.toString();
      });
    });

    // Filter functionality
    document.querySelectorAll('.filter-select').forEach(function(element) {
      element.addEventListener('change', function() {
        const filterBy = this.value;
        const currentParams = new URLSearchParams(window.location.search);
        if (filterBy === 'all') {
          currentParams.delete('filter');
        } else {
          currentParams.set('filter', filterBy);
        }
        window.location.search = currentParams.toString();
      });
    });

    // IINA play button functionality
    document.querySelectorAll('.iina-play-btn').forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const iinaUrl = this.getAttribute('data-iina-url');
        if (iinaUrl) {
          window.location.href = iinaUrl;
        }
      });
    });

    // Mark watched functionality
    document.querySelectorAll('.mark-watched-btn').forEach(button => {
      button.addEventListener('click', function() {
        const filePath = decodeURIComponent(this.getAttribute('data-file'));

        fetch('/mark-watched', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: 'file=' + encodeURIComponent(filePath)
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // If we have a YouTube URL, open it to mark as watched on YouTube
            if (data.youtube_url) {
              window.open(data.youtube_url, '_blank');
            }
            // Reload the page to update the UI
            location.reload();
          } else {
            alert('Error marking video as watched: ' + data.error);
          }
        })
        .catch(error => {
          alert('Error marking video as watched: ' + error);
        });
      });
    });

    // Delete functionality
    document.querySelectorAll('.delete-btn').forEach(button => {
      button.addEventListener('click', function() {
        const filePath = decodeURIComponent(this.getAttribute('data-file'));
        const videoCard = this.closest('.video-card');

        // Get video title for confirmation
        const titleElement = videoCard.querySelector('h3');
        const videoTitle = titleElement ? titleElement.textContent.trim() : 'this video';

        // Show confirmation dialog
        if (!confirm(`Are you sure you want to delete "${videoTitle}"? This action cannot be undone.`)) {
          return;
        }

        // Find the next logical focus target before deletion
        const visibleCards = getVisibleVideoCards();
        const currentIndex = visibleCards.indexOf(videoCard);
        let nextFocusCard = null;

        if (currentIndex >= 0) {
          // Try next card first, then previous if no next
          if (currentIndex < visibleCards.length - 1) {
            nextFocusCard = visibleCards[currentIndex + 1];
          } else if (currentIndex > 0) {
            nextFocusCard = visibleCards[currentIndex - 1];
          }
        }

        fetch('/video', {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: 'file=' + encodeURIComponent(filePath)
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // If we have a YouTube URL, open it to mark as watched on YouTube
            if (data.youtube_url) {
              window.open(data.youtube_url, '_blank');
            }
            // Remove the video card from the UI
            videoCard.remove();

            // Move focus to next logical card
            if (nextFocusCard) {
              const firstElement = getFirstFocusableElementInCard(nextFocusCard);
              if (firstElement) {
                firstElement.focus();
                updateCardHighlight(nextFocusCard);
              }
            } else {
              // No cards left, focus the search input
              const isMobile = window.innerWidth < 768;
              if (isMobile) {
                searchInputMobile.focus();
              } else {
                searchInput.focus();
              }
            }
          } else {
            alert('Error deleting video: ' + data.error);
          }
        })
        .catch(error => {
          alert('Error deleting video: ' + error);
        });
      });
    });
  </script>
</body>
</html>

@@channels
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Manage Channels - Offline YouTube</title>
  <script src="./assets/tailwind-browser.js"></script>
</head>
<body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-white transition-colors duration-200">
  <!-- Header -->
  <header class="bg-gray-100 dark:bg-gray-900 py-3 px-4 md:py-4 md:px-6 border-b border-gray-200 dark:border-gray-700">
    <div class="flex items-center justify-between">
      <div class="flex items-center space-x-2 md:space-x-4">
        <h1 class="text-lg md:text-xl font-bold text-red-500">
          <a href="/">Offline YouTube</a>
        </h1>
        <span class="text-xs md:text-sm text-gray-600 dark:text-gray-300">Channel Management</span>
      </div>
    </div>
  </header>

  <main class="max-w-4xl mx-auto px-4 py-6 md:px-6 md:py-8">
    <div class="mb-6 md:mb-8">
      <h2 class="text-xl md:text-2xl font-bold mb-3 md:mb-4">Channel URL Cache</h2>
      <p class="text-sm md:text-base text-gray-600 dark:text-gray-300 mb-4 md:mb-6">
        Manage cached channel URLs. The app automatically tries @username URLs first, then caches search URLs if they don't work.
      </p>

      <!-- Add New Channel -->
      <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 md:p-6 mb-6 md:mb-8">
        <h3 class="text-base md:text-lg font-semibold mb-3 md:mb-4">Add/Update Channel URL</h3>
        <form method="POST" action="/channel-cache" class="space-y-3 md:space-y-0 md:flex md:gap-4">
          <input type="text" name="channel_name" placeholder="Channel Name" required
            class="w-full md:flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white text-sm md:text-base">
          <input type="url" name="channel_url" placeholder="https://www.youtube.com/@channelname" required
            class="w-full md:flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white text-sm md:text-base">
          <button type="submit" class="w-full md:w-auto px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors text-sm md:text-base">
            Save
          </button>
        </form>
      </div>

      <!-- Channel List -->
      <div class="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700">
        <div class="px-4 py-3 md:px-6 md:py-4 border-b border-gray-200 dark:border-gray-700">
          <h3 class="text-base md:text-lg font-semibold">Cached Channels (<%= @channels&.length || 0 %>)</h3>
        </div>

        <% if @channels&.empty? %>
          <div class="px-4 py-6 md:px-6 md:py-8 text-center text-sm md:text-base text-gray-500 dark:text-gray-300">
            No channels cached yet. URLs will be automatically cached as you browse videos.
          </div>
        <% else %>
          <div class="divide-y divide-gray-200 dark:divide-gray-700">
            <% (@channels || []).each do |channel_name, channel_url| %>
              <!-- Mobile Layout -->
              <div class="md:hidden px-4 py-3">
                <div class="mb-2">
                  <div class="font-medium text-sm"><%= channel_name %></div>
                  <div class="flex items-center mt-1 mb-2">
                    <% if channel_url.include?('youtube.com/@') %>
                      <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200">
                        Direct
                      </span>
                    <% else %>
                      <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200">
                        Search
                      </span>
                    <% end %>
                  </div>
                </div>
                <div class="text-xs text-gray-600 dark:text-gray-300 mb-3">
                  <div class="edit-display">
                    <a href="<%= channel_url %>" target="_blank" class="hover:text-red-500 transition-colors break-all">
                      <%= channel_url %>
                    </a>
                  </div>
                  <form method="POST" action="/channel-cache" class="edit-form hidden">
                    <input type="hidden" name="channel_name" value="<%= channel_name %>">
                    <input type="url" name="channel_url" value="<%= channel_url %>"
                      class="w-full px-2 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                  </form>
                </div>
                <div class="flex items-center justify-between">
                  <div class="flex items-center space-x-3">
                    <button onclick="toggleEdit(this)" class="edit-btn text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 text-xs" title="Edit URL">
                      Edit
                    </button>
                    <button onclick="saveEdit(this)" class="save-btn hidden text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300 text-xs">
                      Save
                    </button>
                    <button onclick="cancelEdit(this)" class="cancel-btn hidden text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-300 text-xs">
                      Cancel
                    </button>
                  </div>
                  <button onclick="confirmDelete('<%= channel_name %>')" class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 text-xs" title="Delete channel">
                    Delete
                  </button>
                </div>
              </div>

              <!-- Desktop Layout -->
              <div class="hidden md:flex px-6 py-4 items-center justify-between">
                <div class="flex-1">
                  <div class="font-medium"><%= channel_name %></div>
                  <div class="text-sm text-gray-600 dark:text-gray-300 mt-1">
                    <div class="edit-display">
                      <a href="<%= channel_url %>" target="_blank" class="hover:text-red-500 transition-colors">
                        <%= channel_url %>
                      </a>
                    </div>
                    <form method="POST" action="/channel-cache" class="edit-form hidden">
                      <input type="hidden" name="channel_name" value="<%= channel_name %>">
                      <input type="url" name="channel_url" value="<%= channel_url %>"
                        class="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                    </form>
                  </div>
                </div>
                <div class="flex items-center space-x-2">
                  <% if channel_url.include?('youtube.com/@') %>
                    <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200">
                      Direct Link
                    </span>
                  <% else %>
                    <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200">
                      Search Link
                    </span>
                  <% end %>
                  <button onclick="toggleEdit(this)" class="edit-btn text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 p-1" title="Edit URL">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/>
                    </svg>
                  </button>
                  <button onclick="saveEdit(this)" class="save-btn hidden text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300 text-sm">
                    Save
                  </button>
                  <button onclick="cancelEdit(this)" class="cancel-btn hidden text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-300 text-sm">
                    Cancel
                  </button>
                  <button onclick="confirmDelete('<%= channel_name %>')" class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 p-1" title="Delete channel">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                  </button>
                </div>
              </div>
            <% end %>
          </div>
        <% end %>
      </div>
    </div>
  </main>

  <script>
    function toggleEdit(button) {
      // Find the row container (works for both mobile px-4 and desktop px-6)
      const row = button.closest('[class*="px-"]');
      const editDisplay = row.querySelector('.edit-display');
      const editForm = row.querySelector('.edit-form');
      const editBtn = row.querySelector('.edit-btn');
      const saveBtn = row.querySelector('.save-btn');
      const cancelBtn = row.querySelector('.cancel-btn');

      editDisplay.classList.add('hidden');
      editForm.classList.remove('hidden');
      editBtn.classList.add('hidden');
      saveBtn.classList.remove('hidden');
      cancelBtn.classList.remove('hidden');

      editForm.querySelector('input[name="channel_url"]').focus();
    }

    function cancelEdit(button) {
      // Find the row container (works for both mobile px-4 and desktop px-6)
      const row = button.closest('[class*="px-"]');
      const editDisplay = row.querySelector('.edit-display');
      const editForm = row.querySelector('.edit-form');
      const editBtn = row.querySelector('.edit-btn');
      const saveBtn = row.querySelector('.save-btn');
      const cancelBtn = row.querySelector('.cancel-btn');

      editDisplay.classList.remove('hidden');
      editForm.classList.add('hidden');
      editBtn.classList.remove('hidden');
      saveBtn.classList.add('hidden');
      cancelBtn.classList.add('hidden');

      // Reset the input value to original
      const originalUrl = editDisplay.querySelector('a').href;
      editForm.querySelector('input[name="channel_url"]').value = originalUrl;
    }

    function saveEdit(button) {
      // Find the row container (works for both mobile px-4 and desktop px-6)
      const row = button.closest('[class*="px-"]');
      const editForm = row.querySelector('.edit-form');
      editForm.submit();
    }

    function confirmDelete(channelName) {
      if (confirm(`Are you sure you want to delete "${channelName}" from the cache?`)) {
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = `/channel-cache/${encodeURIComponent(channelName)}`;

        const methodInput = document.createElement('input');
        methodInput.type = 'hidden';
        methodInput.name = '_method';
        methodInput.value = 'delete';
        form.appendChild(methodInput);

        document.body.appendChild(form);
        form.submit();
      }
    }
  </script>
</body>
</html>
@@end_channels

@@show
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title><%= @video['cleanTitle'] || @video['title'] %> - Offline YouTube</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='h-5 w-5' viewBox='0 0 20 20' fill='red'%3E%3Cpath fill-rule='evenodd' d='M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z' clip-rule='evenodd' /%3E%3C/svg%3E" type="image/svg+xml" />
  <script src="./assets/tailwind-browser.js"></script>
</head>
<body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-white transition-colors duration-200">
  <!-- Header -->
  <header class="bg-gray-100 dark:bg-gray-900 py-4 px-6 border-b border-gray-200 dark:border-gray-700">
    <!-- Mobile Header -->
    <div class="md:hidden flex items-center justify-between">
      <h1 class="text-lg font-bold text-red-500">
        <a href="/">Offline YouTube</a>
      </h1>
      <button id="mobile-menu-toggle" class="p-2 rounded-md text-gray-600 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
      </button>
    </div>

    <!-- Mobile Menu (hidden by default) -->
    <div id="mobile-menu" class="md:hidden hidden mt-4 pb-4 border-t border-gray-200 dark:border-gray-700 pt-4">
      <div class="space-y-4">
        <a href="/channels" class="block text-gray-600 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition-colors">
          Manage Channels
        </a>
        <a href="https://www.youtube.com" target="_blank" class="flex items-center space-x-2 text-red-500 hover:text-red-400">
          <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
          </svg>
          <span>Open YouTube</span>
        </a>
      </div>
    </div>

    <!-- Desktop Header -->
    <div class="hidden md:flex items-center justify-between">
      <div class="flex items-center space-x-4">
        <h1 class="text-xl font-bold text-red-500">
          <a href="/">Offline YouTube</a>
        </h1>
      </div>

      <!-- Search Bar -->
      <div class="max-w-xl flex-1 mx-8">
        <div class="relative">
          <input id="show-search-input" type="text" placeholder="Search videos..."
            class="w-full bg-white dark:bg-gray-700 text-gray-900 dark:text-white px-4 py-2 pl-10 rounded-full focus:outline-none focus:ring-2 focus:ring-red-500 border border-gray-300 dark:border-gray-600">
          <svg class="w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
          </svg>
        </div>
      </div>

      <div class="flex items-center space-x-4">
        <a href="/channels" class="text-gray-600 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition-colors text-sm">
          Manage Channels
        </a>
        <a href="https://www.youtube.com" target="_blank" class="text-red-500 hover:text-red-400">
          <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
          </svg>
        </a>
      </div>
    </div>
  </header>

  <!-- Video Player Section -->
  <div id="video-container" class="w-full max-w-5xl mx-auto px-6 pt-4 pb-4 mb-4 transition-all duration-300">
    <div class="relative">
      <!-- Theater Mode Toggle -->
      <button id="theater-toggle" class="absolute top-2 right-2 z-10 flex items-center justify-center w-8 h-8 bg-black bg-opacity-30 hover:bg-opacity-60 text-white rounded-lg transition-all duration-300 opacity-100" title="Toggle theater mode (T)">
        <svg id="theater-icon" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4a1 1 0 011-1h14a1 1 0 011 1v4m0 0v8a1 1 0 01-1 1H5a1 1 0 01-1-1V8m16 0H4"/>
        </svg>
        <svg id="normal-icon" class="w-4 h-4 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
      <% if @video_file_exists %>
        <div class="relative aspect-video bg-black rounded-lg overflow-hidden">
          <video
            id="main-video"
            controls
            autoplay
            muted
            preload="metadata"
            class="w-full h-full"
            src="/video-file/<%= ERB::Util.url_encode(@video['file'].sub('.json', '.mp4').sub(DOWNLOAD_PATH, '')) %>"
            poster="<%= @video['previewImageURL'] %>"
            data-start-time="<%= @start_time %>">
            Your browser does not support the video tag.
          </video>
        </div>
      <% else %>
        <div class="relative aspect-video bg-gray-200 dark:bg-gray-700 rounded-lg overflow-hidden flex items-center justify-center">
          <img src="<%= @video['previewImageURL'] %>" alt="<%= @video['title'] %>" class="w-full h-full object-cover">
          <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
            <p class="text-white text-lg">Video file not found</p>
          </div>
        </div>
      <% end %>

    </div>
  </div>

  <main class="max-w-5xl mx-auto px-6 pt-2 pb-8">
    <!-- Video Title -->
    <div class="mb-6">
      <h1 class="text-2xl font-bold text-gray-900 dark:text-white">
        <%= @video['cleanTitle'] || @video['title'] %>
      </h1>
    </div>

    <!-- Video Controls -->
    <div class="flex flex-wrap gap-4 mb-6">
      <button class="flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-600 text-white rounded-lg transition-colors iina-play-btn"
              data-iina-url="<%= @video['offlineURL'] %>" title="Play in IINA">
        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 24 24">
          <path d="M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.68L9.54 5.98C8.87 5.55 8 6.03 8 6.82z"/>
        </svg>
        Play in IINA
      </button>

      <a id="youtube-link" href="<%= @video['url'] %>" target="_blank"
        class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600 text-white rounded-lg transition-colors">
        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 24 24">
          <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
        </svg>
        View on YouTube
      </a>

      <button class="flex items-center px-4 py-2 bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-600 text-white rounded-lg transition-colors mark-watched-btn"
              data-file="<%= ERB::Util.url_encode(@video['file']) %>" title="Mark as watched">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
        Mark Watched
      </button>

      <button class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600 text-white rounded-lg transition-colors delete-btn"
              data-file="<%= ERB::Util.url_encode(@video['file']) %>" title="Delete video">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        Delete
      </button>
    </div>

    <!-- Video Info -->
    <div class="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-lg">
      <% if @video['description'] && !@video['description'].empty? %>
        <div class="mb-6">
          <h3 class="text-lg font-semibold mb-3 text-gray-900 dark:text-white">Description</h3>
          <div class="text-sm text-gray-700 dark:text-gray-300">
            <div id="description-preview" class="whitespace-pre-wrap line-clamp-3 overflow-hidden">
              <%= @video['description']&.strip %>
            </div>
            <div id="description-full" class="whitespace-pre-wrap hidden">
              <%= @video['description']&.strip %>
            </div>
            <% if @video['description'].lines.count > 3 || @video['description'].length > 200 %>
              <button id="description-toggle" class="text-red-500 hover:text-red-400 text-sm mt-2 transition-colors">
                Show more
              </button>
            <% end %>
          </div>
        </div>
      <% end %>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <h3 class="text-lg font-semibold mb-3 text-gray-900 dark:text-white">Details</h3>
          <dl class="space-y-2">
            <div>
              <dt class="text-sm font-medium text-gray-500 dark:text-gray-400">Channel</dt>
              <dd class="text-sm text-gray-900 dark:text-white">
                <% if @video['channelUrl'] %>
                  <a href="<%= @video['channelUrl'] %>" target="_blank" class="hover:text-red-500 transition-colors">
                    <%= @video['authors']&.join(', ') %>
                  </a>
                <% else %>
                  <%= @video['authors']&.join(', ') %>
                <% end %>
              </dd>
            </div>
            <div>
              <dt class="text-sm font-medium text-gray-500 dark:text-gray-400">Duration</dt>
              <dd class="text-sm text-gray-900 dark:text-white"><%= @video['length'] %></dd>
            </div>
            <div>
              <dt class="text-sm font-medium text-gray-500 dark:text-gray-400">Upload Date</dt>
              <dd class="text-sm text-gray-900 dark:text-white">
                <time class="relative-time" datetime="<%= @video['uploadDateEpoch'] %>" title="<%= Time.at(@video['uploadDateEpoch']).strftime('%B %d, %Y at %I:%M %p CT') if @video['uploadDateEpoch'] %>">
                  Uploaded
                </time>
              </dd>
            </div>
            <div>
              <dt class="text-sm font-medium text-gray-500 dark:text-gray-400">Watch Status</dt>
              <dd class="text-sm">
                <% if @video['watched'] && !@video['watched'].empty? %>
                  <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200">
                    Watched
                  </span>
                <% else %>
                  <% progress = @video['progress'] || 0 %>
                  <% if progress > 0 %>
                    <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200">
                      <%= progress %>% watched
                    </span>
                  <% else %>
                    <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200">
                      Unwatched
                    </span>
                  <% end %>
                <% end %>
              </dd>
            </div>
          </dl>
        </div>

        <div>
          <h3 class="text-lg font-semibold mb-3 text-gray-900 dark:text-white">Progress</h3>
          <% progress_value = @video['watched'] ? 100 : (@video['progress'] || 0) %>
          <div class="mb-4">
            <div class="flex justify-between text-sm text-gray-600 dark:text-gray-400 mb-1">
              <span>Progress</span>
              <span><%= progress_value %>%</span>
            </div>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
              <div class="bg-red-500 h-2 rounded-full transition-all duration-300" style="width: <%= progress_value %>%"></div>
            </div>
          </div>

          <% if @video_file_exists %>
            <p class="text-sm text-green-600 dark:text-green-400 flex items-center">
              <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
              </svg>
              Video file available
            </p>
          <% else %>
            <p class="text-sm text-red-600 dark:text-red-400 flex items-center">
              <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
              Video file not found
            </p>
          <% end %>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Hide IINA buttons on remote access (non-localhost)
    const isRemote = !['localhost', '127.0.0.1', 'e14.local'].includes(window.location.hostname);
    if (isRemote) {
      document.querySelectorAll('.iina-play-btn').forEach(btn => btn.style.display = 'none');
    }

    // Get the video element for keyboard controls
    const videoElement = document.querySelector('video');

    // Set video start time on load
    if (videoElement) {
      const startTime = parseInt(videoElement.getAttribute('data-start-time')) || 0;
      const baseYouTubeURL = '<%= @video['url'] %>';
      const youtubeLink = document.getElementById('youtube-link');

      // Function to update YouTube link with current timestamp
      function updateYouTubeLink() {
        if (videoElement && youtubeLink) {
          const currentSeconds = Math.floor(videoElement.currentTime);
          const urlWithTimestamp = baseYouTubeURL + (baseYouTubeURL.includes('?') ? '&' : '?') + 't=' + currentSeconds + 's';
          youtubeLink.href = urlWithTimestamp;
        }
      }

      videoElement.addEventListener('loadedmetadata', function() {
        if (startTime > 0) {
          videoElement.currentTime = startTime;
        }
        // Unmute after setting start time to allow autoplay
        videoElement.muted = false;
        // Update YouTube link when video loads
        updateYouTubeLink();
      });

      // Update YouTube link during playback
      videoElement.addEventListener('timeupdate', updateYouTubeLink);
    }

    // Add keyboard controls for video player
    if (videoElement) {
      document.addEventListener('keydown', function(e) {
        // Only handle arrow keys when video is focused or when no input element is focused
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && (
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA' ||
          activeElement.contentEditable === 'true'
        );

        if (!isInputFocused) {
          switch(e.key) {
            case 'ArrowLeft':
              e.preventDefault();
              videoElement.currentTime = Math.max(0, videoElement.currentTime - 10);
              break;
            case 'ArrowRight':
              e.preventDefault();
              videoElement.currentTime = Math.min(videoElement.duration, videoElement.currentTime + 10);
              break;
            case ' ':
            case 'k':
              e.preventDefault();
              if (videoElement.paused) {
                videoElement.play();
              } else {
                videoElement.pause();
              }
              break;
            case 't':
            case 'T':
              e.preventDefault();
              // Toggle theater mode
              const theaterToggleBtn = document.getElementById('theater-toggle');
              if (theaterToggleBtn) {
                theaterToggleBtn.click();
              }
              break;
            case 'y':
            case 'Y':
              e.preventDefault();
              // Open YouTube link with current timestamp
              const youtubeLink = document.getElementById('youtube-link');
              if (youtubeLink) {
                window.open(youtubeLink.href, '_blank');
              }
              break;
            case 'f':
            case 'F':
              e.preventDefault();
              // Toggle fullscreen
              if (!document.fullscreenElement) {
                if (videoElement.requestFullscreen) {
                  videoElement.requestFullscreen();
                } else if (videoElement.webkitRequestFullscreen) {
                  videoElement.webkitRequestFullscreen();
                } else if (videoElement.msRequestFullscreen) {
                  videoElement.msRequestFullscreen();
                }
              } else {
                if (document.exitFullscreen) {
                  document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                  document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                  document.msExitFullscreen();
                }
              }
              break;
            case '/':
              e.preventDefault();
              // Focus search input
              const searchInput = document.getElementById('show-search-input');
              if (searchInput) {
                searchInput.focus();
              }
              break;
            case 'i':
              e.preventDefault();
              // Open in IINA
              const iinaBtn = document.querySelector('.iina-play-btn');
              if (iinaBtn) {
                iinaBtn.click();
              }
              break;
            case 'c':
              e.preventDefault();
              // Open channel
              const channelLink = document.querySelector('a[href*="youtube.com"]:not([href*="watch"])');
              if (channelLink) {
                channelLink.click();
              }
              break;
            case 'w':
              e.preventDefault();
              // Mark watched
              const watchedBtn = document.querySelector('.mark-watched-btn');
              if (watchedBtn) {
                watchedBtn.click();
              }
              break;
            case 'd':
              e.preventDefault();
              // Delete video
              const deleteBtn = document.querySelector('.delete-btn');
              if (deleteBtn) {
                deleteBtn.click();
              }
              break;
            case 'y':
              e.preventDefault();
              // Open in YouTube
              const videoUrl = '<%= @video["url"] %>';
              if (videoUrl) {
                window.open(videoUrl, '_blank');
              }
              break;
            case 'Y':
              e.preventDefault();
              // Open youtube.com
              if (e.shiftKey) {
                // Open in new tab
                window.open('https://www.youtube.com', '_blank');
              } else {
                const youtubeLink = document.querySelector('a[href="https://www.youtube.com"]');
                if (youtubeLink) {
                  youtubeLink.click();
                }
              }
              break;
          }
        }
      });
    }

    // IINA play button functionality
    document.querySelectorAll('.iina-play-btn').forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const iinaUrl = this.getAttribute('data-iina-url');
        if (iinaUrl) {
          window.location.href = iinaUrl;
        }
      });
    });

    // Mark watched functionality
    document.querySelectorAll('.mark-watched-btn').forEach(button => {
      button.addEventListener('click', function() {
        const filePath = decodeURIComponent(this.getAttribute('data-file'));

        fetch('/mark-watched', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: 'file=' + encodeURIComponent(filePath)
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // If we have a YouTube URL, open it to mark as watched on YouTube
            if (data.youtube_url) {
              window.open(data.youtube_url, '_blank');
            }
            // Reload the page to update the UI
            location.reload();
          } else {
            alert('Error marking video as watched: ' + data.error);
          }
        })
        .catch(error => {
          alert('Error marking video as watched: ' + error);
        });
      });
    });

    // Delete functionality
    document.querySelectorAll('.delete-btn').forEach(button => {
      button.addEventListener('click', function() {
        if (!confirm('Are you sure you want to delete this video? This action cannot be undone.')) {
          return;
        }

        const filePath = decodeURIComponent(this.getAttribute('data-file'));

        fetch('/video', {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: 'file=' + encodeURIComponent(filePath)
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // If we have a YouTube URL, open it to mark as watched on YouTube
            if (data.youtube_url) {
              window.open(data.youtube_url, '_blank');
            }
            // Redirect back to the main page
            window.location.href = '/';
          } else {
            alert('Error deleting video: ' + data.error);
          }
        })
        .catch(error => {
          alert('Error deleting video: ' + error);
        });
      });
    });

    // Theater mode toggle functionality
    const theaterToggle = document.getElementById('theater-toggle');
    const videoContainer = document.getElementById('video-container');
    const theaterIcon = document.getElementById('theater-icon');
    const normalIcon = document.getElementById('normal-icon');

    // Auto-hide theater button functionality
    let hideTimeout;

    function showTheaterButton() {
      theaterToggle.style.opacity = '1';
      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        theaterToggle.style.opacity = '0';
      }, 3000); // Hide after 3 seconds of no mouse movement
    }

    function keepTheaterButtonVisible() {
      theaterToggle.style.opacity = '1';
      clearTimeout(hideTimeout);
    }

    if (theaterToggle && videoContainer) {
      // Show button on mouse movement over video container
      videoContainer.addEventListener('mousemove', showTheaterButton);
      videoContainer.addEventListener('mouseenter', showTheaterButton);

      // Keep button visible when hovering over it
      theaterToggle.addEventListener('mouseenter', keepTheaterButtonVisible);
      theaterToggle.addEventListener('mouseleave', showTheaterButton);

      // Initial auto-hide
      showTheaterButton();
      // Always start in theater mode
      enableTheaterMode();

      // Mobile menu toggle
      const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
      const mobileMenu = document.getElementById('mobile-menu');

      if (mobileMenuToggle && mobileMenu) {
        mobileMenuToggle.addEventListener('click', function() {
          mobileMenu.classList.toggle('hidden');
        });
      }

      theaterToggle.addEventListener('click', function() {
        const isCurrentlyTheater = videoContainer.classList.contains('w-[95%]');

        if (isCurrentlyTheater) {
          disableTheaterMode();
        } else {
          enableTheaterMode();
        }
      });

      function enableTheaterMode() {
        // Temporarily disable transitions for smooth theater mode change
        videoContainer.style.transition = 'none';
        videoContainer.classList.remove('w-full', 'max-w-5xl');
        videoContainer.classList.add('w-[95%]');
        theaterIcon.classList.add('hidden');
        normalIcon.classList.remove('hidden');
        localStorage.setItem('theaterMode', 'true');
        // Re-enable transitions after a brief delay
        setTimeout(() => {
          videoContainer.style.transition = '';
        }, 50);
      }

      function disableTheaterMode() {
        // Temporarily disable transitions for smooth theater mode change
        videoContainer.style.transition = 'none';
        videoContainer.classList.remove('w-[95%]');
        videoContainer.classList.add('w-full', 'max-w-5xl');
        theaterIcon.classList.remove('hidden');
        normalIcon.classList.add('hidden');
        localStorage.setItem('theaterMode', 'false');
        // Re-enable transitions after a brief delay
        setTimeout(() => {
          videoContainer.style.transition = '';
        }, 50);
      }
    }

    // Auto-scroll to video player on page load
    window.addEventListener('load', function() {
      const videoContainer = document.getElementById('video-container');
      if (videoContainer) {
        videoContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    });

    // IINA progress sync functionality
    const currentFilePath = '<%= ERB::Util.url_encode(@video["file"]) %>';
    let progressSyncInterval;

    function syncProgressWithIINA() {
      fetch('/sync-progress', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'file=' + encodeURIComponent(decodeURIComponent(currentFilePath))
      })
      .then(response => response.json())
      .then(data => {
        if (data.success && data.progress !== undefined) {
          // Update progress bar if it exists
          const progressBar = document.querySelector('.bg-red-500');
          if (progressBar) {
            const progressValue = Math.min(100, Math.max(0, data.progress));
            progressBar.style.width = progressValue + '%';

            // Update progress text
            const progressText = document.querySelector('.bg-red-500').closest('.w-full').previousElementSibling;
            if (progressText && progressText.querySelector('span:last-child')) {
              progressText.querySelector('span:last-child').textContent = progressValue + '%';
            }
          }
        }
      })
      .catch(error => {
        console.log('Progress sync failed:', error);
      });
    }

    // Start progress sync when video is playing in the web player
    if (videoElement) {
      videoElement.addEventListener('play', function() {
        // Sync immediately when play starts
        syncProgressWithIINA();

        // Then sync every 30 seconds while playing
        if (progressSyncInterval) {
          clearInterval(progressSyncInterval);
        }
        progressSyncInterval = setInterval(syncProgressWithIINA, 30000);
      });

      videoElement.addEventListener('pause', function() {
        // Stop syncing when paused
        if (progressSyncInterval) {
          clearInterval(progressSyncInterval);
        }
      });

      videoElement.addEventListener('ended', function() {
        // Final sync when video ends
        syncProgressWithIINA();
        if (progressSyncInterval) {
          clearInterval(progressSyncInterval);
        }
      });
    }

    // Convert timestamps to relative time
    function timeAgo(timestamp) {
      const now = Math.floor(Date.now() / 1000);
      const diff = now - timestamp;

      if (diff < 60) return 'just now';
      if (diff < 3600) return Math.floor(diff / 60) + ' minutes ago';
      if (diff < 86400) return Math.floor(diff / 3600) + ' hours ago';
      if (diff < 2592000) return Math.floor(diff / 86400) + ' days ago';
      if (diff < 31536000) return Math.floor(diff / 2592000) + ' months ago';
      return Math.floor(diff / 31536000) + ' years ago';
    }

    function updateRelativeTimes() {
      document.querySelectorAll('.relative-time').forEach(timeEl => {
        const timestamp = parseInt(timeEl.getAttribute('datetime'));
        if (timestamp) {
          timeEl.textContent = 'Uploaded ' + timeAgo(timestamp);
        }
      });
    }

    // Update relative times on load and every minute
    updateRelativeTimes();
    setInterval(updateRelativeTimes, 60000);

    // Sync progress from web player to IINA metadata files
    function syncProgressToIINA() {
      if (!videoElement || videoElement.duration === 0) return;

      const currentProgress = Math.round((videoElement.currentTime / videoElement.duration) * 100);

      fetch('/sync-progress', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'file=' + encodeURIComponent(decodeURIComponent(currentFilePath)) + '&web_progress=' + currentProgress + '&web_time=' + Math.floor(videoElement.currentTime)
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Update progress bar if it exists
          const progressBar = document.querySelector('.bg-red-500');
          if (progressBar) {
            progressBar.style.width = currentProgress + '%';

            // Update progress text
            const progressText = document.querySelector('.bg-red-500').closest('.w-full').previousElementSibling;
            if (progressText && progressText.querySelector('span:last-child')) {
              progressText.querySelector('span:last-child').textContent = currentProgress + '%';
            }
          }

          // Update YouTube link with new timestamp if provided
          if (data.youtube_url) {
            const youtubeLink = document.querySelector('a[href*="youtube.com"]');
            if (youtubeLink) {
              youtubeLink.href = data.youtube_url;
            }
          }
        }
      })
      .catch(error => {
        console.log('Progress sync failed:', error);
      });
    }

    // Also sync when page loads (in case IINA was used outside the web app)
    syncProgressWithIINA();

    // Sync web player progress to IINA more frequently
    if (videoElement) {
      // Sync on play/pause events
      videoElement.addEventListener('play', syncProgressToIINA);
      videoElement.addEventListener('pause', syncProgressToIINA);
      videoElement.addEventListener('ended', syncProgressToIINA);

      // Sync every 10 seconds during playback
      videoElement.addEventListener('timeupdate', function() {
        if (!videoElement._lastSyncTime || Date.now() - videoElement._lastSyncTime > 10000) {
          syncProgressToIINA();
          videoElement._lastSyncTime = Date.now();
        }
      });
    }

    // Description toggle functionality
    const descriptionToggle = document.getElementById('description-toggle');
    const descriptionPreview = document.getElementById('description-preview');
    const descriptionFull = document.getElementById('description-full');

    if (descriptionToggle && descriptionPreview && descriptionFull) {
      descriptionToggle.addEventListener('click', function() {
        if (descriptionFull.classList.contains('hidden')) {
          // Show full description
          descriptionPreview.classList.add('hidden');
          descriptionFull.classList.remove('hidden');
          descriptionToggle.textContent = 'Show less';
        } else {
          // Show preview
          descriptionFull.classList.add('hidden');
          descriptionPreview.classList.remove('hidden');
          descriptionToggle.textContent = 'Show more';
        }
      });
    }

    // Search functionality - redirect to index with search query
    const showSearchInput = document.getElementById('show-search-input');
    if (showSearchInput) {
      showSearchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const query = e.target.value.trim();
          if (query) {
            // Redirect to index with search query in URL fragment for the search script to pick up
            window.location.href = `/?search=${encodeURIComponent(query)}`;
          } else {
            // Just go to index if empty search
            window.location.href = '/';
          }
        }
      });
    }
  </script>
</body>
</html>
@@end_show
